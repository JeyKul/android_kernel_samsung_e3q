/* SPDX-License-Identifier: GPL-2.0-only */
/*
 * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
 */

#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <linux/types.h>
#include "smcinvoke_object.h"

#define HDCP1_PROVISION 0
#define HDCP1_VERIFY 1
#define HDCP1_SET_ENCRYPTION 2
#define HDCP1_SET_ENCRYPTION_V2 3
#define HDCP1_SET_KEY 4
#define HDCP1_SET_KEY_V2 5
#define HDCP1_SET_MODE 6

static inline int32_t hdcp1_release(struct Object self)
{
	return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t hdcp1_retain(struct Object self)
{
	return Object_invoke(self, Object_OP_retain, 0, 0);
}

static inline int32_t hdcp1_provision(struct Object self, uint32_t keyFormat_val,
		   const void *key_ptr, size_t key_len,
		   const void *dps_ptr, size_t dps_len)
{
	union ObjectArg a[3] = {{{0, 0}}};

	a[0].b = (struct ObjectBuf) {&keyFormat_val, sizeof(uint32_t)};
	a[1].bi = (struct ObjectBufIn) {key_ptr, key_len * 1};
	a[2].bi = (struct ObjectBufIn) {dps_ptr, dps_len * 1};

	return Object_invoke(self, HDCP1_PROVISION, a,
		 ObjectCounts_pack(3, 0, 0, 0));
}

static inline int32_t hdcp1_verify(struct Object self, uint32_t deviceType_val)
{
	union ObjectArg a[1] = {{{0, 0}}};

	a[0].b = (struct ObjectBuf) {&deviceType_val, sizeof(uint32_t)};

	return Object_invoke(self, HDCP1_VERIFY, a,
		 ObjectCounts_pack(1, 0, 0, 0));
}

static inline int32_t hdcp1_set_encryption(struct Object self, uint32_t enable_val)
{
	union ObjectArg a[1] = {{{0, 0}}};

	a[0].b = (struct ObjectBuf) {&enable_val, sizeof(uint32_t)};

	return Object_invoke(self, HDCP1_SET_ENCRYPTION, a,
		 ObjectCounts_pack(1, 0, 0, 0));
}

static inline int32_t hdcp1_set_encryption_v2(struct Object self, uint32_t enable_val,
		   uint32_t deviceType_val)
{
	union ObjectArg a[1] = {{{0, 0}}};
	struct {
		uint32_t m_enable;
		uint32_t m_deviceType;
	} i;

	a[0].b = (struct ObjectBuf) {&i, 8};
	i.m_enable = enable_val;
	i.m_deviceType = deviceType_val;

	return Object_invoke(self, HDCP1_SET_ENCRYPTION_V2, a,
		 ObjectCounts_pack(1, 0, 0, 0));
}

static inline int32_t hdcp1_set_key(struct Object self, void *ksv_ptr, size_t ksv_len,
		 size_t *ksv_lenout)
{
	union ObjectArg a[1] = {{{0, 0}}};
	int32_t result = 0;

	a[0].b = (struct ObjectBuf) {ksv_ptr, ksv_len * 1};

	result = Object_invoke(self, HDCP1_SET_KEY, a,
		   ObjectCounts_pack(0, 1, 0, 0));

	*ksv_lenout = a[0].b.size / 1;

	return result;
}

static inline int32_t hdcp1_set_key_v2(struct Object self, void *ksv_ptr,
		size_t ksv_len, size_t *ksv_lenout,
		uint32_t deviceType_val)
{
	union ObjectArg a[2] = {{{0, 0}}};
	int32_t result = 0;

	a[1].b = (struct ObjectBuf) {ksv_ptr, ksv_len * 1};
	a[0].b = (struct ObjectBuf) {&deviceType_val, sizeof(uint32_t)};

	result = Object_invoke(self, HDCP1_SET_KEY_V2, a,
		   ObjectCounts_pack(1, 1, 0, 0));

	*ksv_lenout = a[1].b.size / 1;

	return result;
}

static inline int32_t hdcp1_set_mode(struct Object self, int32_t mode_val)
{
	union ObjectArg a[1] = {{{0, 0}}};

	a[0].b = (struct ObjectBuf) {&mode_val, sizeof(int32_t)};

	return Object_invoke(self, HDCP1_SET_MODE, a,
		 ObjectCounts_pack(1, 0, 0, 0));
}
